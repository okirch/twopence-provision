#!/usr/bin/python3

from _twopence.provision import *

global_config_files	= [
	"twopence.conf",
	"provision.conf",
]

def action_help(args):
	parser.print_help()
	exit(0)

def create_topology(args, purpose = None):
	bom = BOM(args.workspace)

	if not bom.load():
		raise ValueError("Failed to load BOM from %s" % bom.path)

	backend = Backend.create(bom.backend)
	config = load_config(bom)

	config.validate(purpose = purpose)

	topology = TestTopology(backend, config = config, workspace = args.workspace)
	return topology

def provision_topology(topology):
	if topology.detect():
		print("One or more VMs seem to exist.")
		for instance in topology.instances:
			print("  %s" % instance.name)

		if not args.auto_destroy:
			print("Please destroy these instances first, or invoke this command with --auto-destroy")
			exit(1)

		verbose("Auto-destroying these instances NOW")
		topology.stop(destroy = True)

		topology.detect()
		if topology.hasRunningInstances():
			print("Cannot stop all VMs - giving up")
			exit(1)

		topology.destroy()
		topology.cleanup()

	if not topology.prepare():
		print("Unable to prepare all instances")
		exit(1)

	if not topology.start():
		print("Unable to start build instance")
		exit(1)

def load_config(bom, validate = True):
	config = Config(bom.workspace)

	config.status = bom.status
	config.logspace = bom.logspace

	for path in global_config_files:
		config.load(path)

	# Note: we load global config files first; THEN
	# we add user directories to the config search path.
	config.addDirectory(twopence_user_config_dir)

	for path in bom.config:
		config.load(path)

	if validate:
		config.validate()
	return config

def action_init(args):
	workspace = args.workspace

	bom = BOM(args.workspace)

	if bom.exists:
		print("BOM file %s seems to exist, refusing to initialize" % bom.path)
		exit(1)

	bom.backend = args.backend
	bom.logspace = args.logspace
	for path in args.config:
		bom.addConfig(path)

	bom.save()

	try:
		config = load_config(bom, validate = False)
	except ConfigError as e:
		print("Error: the resulting configuration is not valid")
		print(e)
		exit(2)

	return

	backend = Backend.create(bom.backend)
	# This will create status.conf
	TestTopology(backend, config = config, workspace = args.workspace)

def action_build(args):
	print(args)
	if not args.target:
		print("Missing argument: name of target build")
		exit(1)

	bom = BOM(args.workspace)
	if not bom.load():
		raise ValueError("Failed to load BOM from %s" % bom.path)

	config = load_config(bom, validate = False)

	build_config = "/usr/lib/twopence/provision/%s/build.conf" % args.target
	if not config.load(build_config):
		raise ValueError("Cannot find %s" % build_config)

	buildNode = config.findBuildNode()
	if buildNode is None:
		raise ValueError("Cannot find the build node")

	build = config.getBuild(buildNode.build)
	if not build:
		raise ValueError("Cannot find a valid build description")

	verbose("Using %s" % build)

	build.resolveImage(config, backend = bom.backend)

	# FIXME: hack
	config.testcase = "build"

	backend = Backend.create(bom.backend)
	topology = TestTopology(backend, config = config, workspace = args.workspace)

	# This provisions the build node - and with that, we're already done.
	provision_topology(topology)

	verbose("stopping cluster")
	topology.stop()
	topology.detect()
	if topology.hasRunningInstances():
		print("Cannot stop all VMs - giving up")
		exit(1)

	topology.package(buildNode.name)

	topology.destroy()
	topology.cleanup()

def action_create(args):
	topology = create_topology(args, purpose = "testing")
	# FIXME: use provision_topology()
	if topology.detect():
		print("One or more VMs seem to exist.")
		for instance in topology.instances:
			print("  %s" % instance.name)

		if not args.auto_destroy:
			print("Please destroy these instances first, or invoke this command with --auto-destroy")
			exit(1)

		verbose("Auto-destroying these instances NOW")
		topology.stop(destroy = True)

		topology.detect()
		if topology.hasRunningInstances():
			print("Cannot stop all VMs - giving up")
			exit(1)

		topology.destroy()
		topology.cleanup()

	if not topology.prepare():
		print("Unable to prepare all instances")
		exit(1)

	topology.start()

def action_destroy(args):
	topology = create_topology(args)
	if not topology.detect():
		verbose("Nothing to destroy")
	else:
		print("Detected running instance(s):")
		for instance in topology.instances:
			print("  %s" % instance.name)

		verbose("Destroying these instances")
		topology.stop()

		topology.detect()
		if topology.hasRunningInstances():
			print("Cannot stop all VMs - giving up")
			exit(1)

	topology.destroy()
	topology.cleanup()

def action_status(args):
	topology = create_topology(args)
	if not topology.detect(detectNetwork = True):
		verbose("No instances")
	else:
		print("Detected instance(s) for testcase %s:" % topology.testcase)
		for instance in topology.instances:
			addresses = []
			for nif in instance.networkInterfaces:
				addresses.append(str(nif))

			if addresses:
				address = addresses.pop(0)
			else:
				address = ''

			print("  %-20s %-10s %s" % (instance.name,
					instance.running and "running" or "stopped",
					address))

			while addresses:
				address = addresses.pop(0)
				print(" %*.32s %s" % ('', address))

def action_show(args):
	topology = create_topology(args)
	for type in args.info_type:
		if type == 'status-file':
			st = topology.persistentState
			print(st.path or "")
		else:
			raise ValueError("Unsupported info-type \"%s\"" % type)

def build_arg_parser():
	import argparse

	parser = argparse.ArgumentParser(description = 'Provision test instances.')
	parser.add_argument('--workspace',
			    help = 'the directory to use as workspace')
	parser.add_argument('--quiet', default = False, action = 'store_true',
			    help = 'Disable most output')
	parser.add_argument('--status',
			    help = 'path to the file to store status info [default $workspace/status.conf]')
	parser.add_argument('--debug', default = False, action = 'store_true',
			    help = 'Enable debug output')

	sub = parser.add_subparsers(dest = 'command')

	sp = sub.add_parser('init', help = 'Initialize a run')
	sp.set_defaults(action = action_init)
	sp.add_argument('--config', action = 'append', default = [],
			help='path to the file describing the nodes to be provisioned')
	sp.add_argument('--backend', default = 'vagrant',
			help = 'the provisioning backend to use [vagrant]')
	sp.add_argument('--logspace',
			help = 'the default location for test runs to write their log files to')

	sp = sub.add_parser('build', help = 'Build a silver image')
	sp.set_defaults(action = action_build)
	sp.add_argument('--auto-destroy', default = False, action = 'store_true',
			help = 'if one or more of the requested nodes are running, destroy them')
	sp.add_argument('target', metavar='TARGET', nargs='?',
			help = 'name of the target image to be built')

	sp = sub.add_parser('create', help = 'Create the requested nodes')
	sp.set_defaults(action = action_create)
	sp.add_argument('--auto-destroy', default = False, action = 'store_true',
			help = 'if one or more of the requested nodes are running, destroy them')

	sp = sub.add_parser('destroy', help = 'Destroy the topology')
	sp.set_defaults(action = action_destroy)

	sp = sub.add_parser('status', help = 'Display status on the topology')
	sp.set_defaults(action = action_status)

	sp = sub.add_parser('show', help = 'Display info on the test case')
	sp.set_defaults(action = action_show)
	sp.add_argument('info_type', metavar='INFO-TYPE', nargs = '+',
			help='info type to display (status-file, ...)')

	sp = sub.add_parser('help', help = 'Print this message')
	sp.set_defaults(action = action_help)

	return parser


parser = build_arg_parser()
args = parser.parse_args()

if args.debug:
	setVerbosity(2)
elif not args.quiet:
	setVerbosity(1)
else:
	setVerbosity(0)

if not args.command:
	print("Error: missing subcommand")
	parser.print_help()
	exit(2)

if args.workspace is None:
	print("Error: missing --workspace option")
	parser.print_help()
	exit(2)

args.action(args)
