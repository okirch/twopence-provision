#!/usr/bin/python3

global_config_paths	= [
	"/etc/twopence/twopence.conf",
	"/etc/twopence/provision.conf",
]

import susetest
import curly
import sys
import os
import time

opt_verbose = 1

def debug_enabled():
	return opt_verbose >= 2

def verbose_enabled():
	return opt_verbose >= 1

def debug(msg):
	if opt_verbose >= 2:
		print("DEBUG: %s" % msg)

def verbose(msg):
	if opt_verbose >= 1:
		print("%s" % msg)

class ConfigError(Exception):
	pass

class Configurable:
	def update_value(self, config, attr_name, config_key = None):
		if config_key is None:
			config_key = attr_name
		value = config.get_value(config_key)
		if value is not None:
			setattr(self, attr_name, value)

	def update_list(self, config, attr_name):
		# get_values may return None or []
		value = config.get_values(attr_name)
		if value:
			current = getattr(self, attr_name)
			assert(type(current) == list)
			setattr(self, attr_name, current + value)

class ProgressBar:
	def __init__(self, message):
		self.message = message
		self.printed = False
		self.enabled = True

	def __del__(self):
		self.finish()

	def disable(self):
		self.enabled = False

	def tick(self):
		if not self.enabled:
			return

		if not self.printed:
			sys.stdout.write(self.message + " ")
			self.printed = True
		sys.stdout.write(".")
		sys.stdout.flush()

	def finish(self, msg = "done"):
		if self.printed:
			print(" %s" % msg)
			self.printed = False

class ExecStatus:
	RUNNING = 0
	TIMED_OUT = 1
	EXITED = 2
	CRASHED = 3

	def __init__(self, how, exit_code = None, output = None):
		self.how = how

		if how != self.EXITED:
			exit_code = None
		self.exit_code = exit_code

		self.output = output

	@classmethod
	def timedOut(klass, *args, **kwargs):
		return klass(klass.TIMED_OUT, *args, **kwargs)

	@classmethod
	def exited(klass, *args, **kwargs):
		return klass(klass.EXITED, *args, **kwargs)

	def __bool__(self):
		return self.exit_code == 0

	def __str__(self):
		if self.how == self.RUNNING:
			return "running"
		if self.how == self.TIMED_OUT:
			return "timed out"
		if self.how == self.EXITED:
			return "exited with code %d" % self.exit_code
		if self.how == self.CRASHED:
			return "crashed"

		return "UNKNOWN"

	@property
	def output_lines(self):
		if self.output is None:
			return []
		return self.output.split("\n")

class Network:
	AF_IPv4 = 4
	AF_IPv6 = 6

	VALID_FAMILIES = (AF_IPv4, AF_IPv6)

class NetworkInterface:
	def __init__(self, family, address = None, prefix_len = None):
		assert(family in Network.VALID_FAMILIES)

		if prefix_len is None:
			if family == Network.AF_IPv4:
				prefix_len = 24
			elif family == Network.AF_IPv6:
				prefix_len = 64
			else:
				raise ValueError("not default prefix len for AF %s" % af)

		self.family = family
		self.address = address
		self.prefix_len = prefix_len
		self.network = "%s/%s" % (address, prefix_len)

	def __str__(self):
		return "%s/%s" % (self.address, self.prefix_len)

class GenericInstance:
	def __init__(self, instanceConfig, workspace, persistentState = None):
		self.config = instanceConfig
		self.workspace = workspace
		self.persistent = persistentState
		self.name = instanceConfig.name

		self.exists = False

		self.running = False
		self.networkInterfaces = []

	def addNetworkInterface(self, af, address, prefix_len = None):
		af = int(af)

		nif = NetworkInterface(af, address, prefix_len)
		self.networkInterfaces.append(nif)

		# Reflect the first address of this family in the status file
		self.persistNetwork()

	def clearNetworkInterfaces(self):
		self.networkInterfaces = []
		self.persistNetwork()

	def fetchNeworksFromPersistentState(self):
		if self.persistent is None:
			return

		self.networkInterfaces = []

		address = self.persistent.ipv4_address
		if address:
			self.addNetworkInterface(Network.AF_IPv4, address)
		address = self.persistent.ipv6_address
		if address:
			self.addNetworkInterface(Network.AF_IPv6, address)

	def persistNetwork(self):
		if self.persistent is None:
			return

		self.persistent.ipv4_address = self.getFirstNetworkAddress(Network.AF_IPv4)
		self.persistent.ipv6_address = self.getFirstNetworkAddress(Network.AF_IPv6)

	def getFirstNetworkAddress(self, af):
		for nif in self.networkInterfaces:
			if nif.family == af:
				return nif.address
		return None

	def recordStartTime(self, when):
		if self.persistent is None:
			return

		self.persistent.set_value("start-time", when)

	def recordKeyfile(self, path):
		if self.persistent is None:
			return

		self.persistent.set_value("keyfile", path)

	def recordTarget(self, target):
		if self.persistent is None:
			return

		self.persistent.set_value("target", target)

	def saveLog(self, filename, buffer):
		with self.openLog(filename) as f:
			f.write(buffer)

	def saveExecStatus(self, filename, status):
		with self.openLog(filename) as f:
			print("%s %s" % (time.ctime(), status), file = f)
			if status.output:
				print("Command output follows", file = f)
				f.write(status.output)

	def openLog(self, filename):
		path = os.path.join(self.workspace, filename)
		return open(path, "w")

class Backend(Configurable):
	@staticmethod
	def create(family):
		if family == 'vagrant':
			return VagrantBackend()

		raise ConfigError("Cannot create backend \"%s\" - unknown backend family" % family)

class VagrantInstance(GenericInstance):
	def setStateFromVagrantStatus(self, raw_status):
		# debug("setStateFromVagrantStatus(%s, raw=%s, persistent=%s)" % (self.name, raw_status, self.persistent))
		if raw_status in ('preparing', 'running', ):
			self.running = True

			self.fetchNeworksFromPersistentState()
		elif raw_status in ('not_started', 'shutoff', 'not_created'):
			self.running = False

			self.clearNetworkInterfaces()
		else:
			raise ValueError("Vagrant instance %s/default is in state %s - huh?!" % (
					self.name, raw_status))

		self.raw_state = raw_status

class VagrantBackend(Backend):
	name = "vagrant"

	def __init__(self):
		self.template = None

	def configure(self, config):
		self.update_value(config, 'template')

	def detect(self, workspace, status, expectedInstanceConfigs):
		assert(workspace)

		found = []
		for instanceConfig in expectedInstanceConfigs:
			savedState = status.createNodeState(instanceConfig.name)

			instance = self.detectInstance(workspace, instanceConfig, savedState)
			if instance:
				found.append(instance)

		for savedInstanceState in status.nodes:
			if any(instance.name == savedInstanceState.name for instance in found):
				continue

			dummy = InstanceConfig(savedInstanceState.name)
			instance = self.detectInstance(workspace, dummy, savedInstanceState)
			if instance:
				found.append(instance)

		return found

	def detectInstance(self, workspace, instanceConfig, savedInstanceState = None):
		assert(workspace)

		debug("detectInstance(%s)" % instanceConfig.name)
		instanceWorkspace = os.path.join(workspace, instanceConfig.name)
		if not os.path.isdir(instanceWorkspace):
			return None

		debug("Instance %s: workspace exists" % instanceConfig.name)

		instance = VagrantInstance(instanceConfig, instanceWorkspace, savedInstanceState)
		instance.exists = True

		# This calls setStateFromVagrantStatus(), which will do one of these
		# - if a VM is running, instance.networkInterfaces is initialized from
		#   the node's persistent state
		# - if no VM is running, clear instance.networkInterfaces and update
		#   the node's persistent state (ie delete ipv4_address and friends)
		self.detectInstanceState(instance)

		debug("Detected instance %s (state %s)" % (instance.name, instance.raw_state))
		return instance

	def prepareInstance(self, workspace, instanceConfig, savedInstanceState):
		assert(workspace)

		if not self.template:
			raise ValueError("Cannot prepare vagrant instance - no template defined")

		instanceWorkspace = os.path.join(workspace, instanceConfig.name)
		if os.path.isdir(instanceWorkspace):
			raise ValueError("workspace %s already exists" % instanceWorkspace)

		os.makedirs(instanceWorkspace)

		path = os.path.join(workspace, instanceConfig.name, "Vagrantfile")

		extraCommands = [
			# This tells the twopence server where to listen for incoming
			# connections.
			"echo 'port tcp { port 4000; }' >/etc/twopence/ports.conf",
#			"rm -f /etc/twopence/twopence.conf",
		]

		instanceConfig.processTemplate(self.template, path, extraCommands)

		if savedInstanceState:
			savedInstanceState.set_features(instanceConfig.features)

		return VagrantInstance(instanceConfig, instanceWorkspace, savedInstanceState)

	def startInstance(self, instance):
		if instance.running:
			print("Cannot start instance %s - already running" % instance.name)
			return False

		when = time.ctime()

		print("Starting %s instance" % instance.name)
		status = self.runShellCmd("vagrant up", cwd = instance.workspace, timeout = 120)

		verbose("Saving output to vagrant_up.log")
		instance.saveExecStatus("vagrant_up.log", status)

		if status.exit_code != 0:
			print("Cannot start instance %s - vagrant up failed" % instance.name)
			if status.output and verbose_enabled():
				verbose("-- COMMAND OUTPUT --")
				verbose(status.output)
				if not status.output.endswith('\n'):
					verbose()
				print("-- END COMMAND OUTPUT --")

			return False

		import re

		for line in status.output_lines:
			if "SSH address" not in line:
				continue

			m = re.match(".*SSH address[: ]*(\d+\.\d+\.\d+\.\d+):(\d+).*", line)
			if m:
				address = m.group(1)
				verbose("Detected SSH address %s" % address)
				instance.addNetworkInterface(Network.AF_IPv4, address)
			else:
				print("Bad: unable to parse address in output of \"vagrant up\"")
				print("  ->> %s" % line.strip())

		instance.recordStartTime(when)
		instance.recordKeyfile(instance.config.keyfile)

		return True

	def updateInstanceTarget(self, instance):
		target = None

		if instance.exists:
			addr = instance.getFirstNetworkAddress(Network.AF_IPv4)
			if addr:
				# hard-coded for now
				target = "tcp:%s:4000" % addr

		instance.recordTarget(target)

	def detectInstanceState(self, instance):
		status = self.runVagrant("status --machine-readable", instance, quiet = True)
		if not status:
			# We could fall back to using virsh directly...
			raise ValueError("%s: vagrant status failed: %s" % (instance.name, status))

		for line in status.output_lines:
			if not line:
				continue

			(ts, name, what, rest) = line.split(',', maxsplit = 3)
			if what == 'state' and name == 'default':
				instance.setStateFromVagrantStatus(rest)

		return True

	def detectInstanceNetwork(self, instance):
		# unfortunately, "vagrant ssh-config" dies on me with a timeout...
		return False

	def stopInstance(self, instance, force = False, destroy = False):
		if destroy:
			return self.destroyInstance(instance)

		if not instance.running and not force:
			return

		verbose("Stopping %s instance" % instance.name)
		status = self.runVagrant("halt", instance, timeout = 30)
		if not status:
			raise ValueError("%s: vagrant halt failed: %s" % (instance.name, status))

		self.detectInstanceState(instance)
		if instance.running:
			print("%s: vagrant halt failed to stop VM" % instance.name)
			return False

		instance.recordStartTime(None)
		return True

	def destroyInstance(self, instance):
		verbose("Destroying %s instance" % instance.name)
		status = self.runVagrant("destroy -f", instance, timeout = 30)
		if not status:
			raise ValueError("%s: vagrant destroy failed: %s" % (instance.name, status))

		import shutil

		shutil.rmtree(instance.workspace)
		instance.dead = True
		instance.exists = False

		return True

	def runVagrant(self, subcommand, instance, retries = 3, **kwargs):
		for i in range(retries):
			status = self.runShellCmd("vagrant " + subcommand, cwd = instance.workspace, **kwargs)
			if status:
				break

			verbose("vagrant %s failed, retrying" % subcommand)

		return status

	def runShellCmd(self, command, cwd = None, timeout = 10, quiet = False):
		import subprocess
		import time

		progress = ProgressBar("Waiting for command to complete")
		if quiet:
			progress.disable()
		elif cwd:
			print("Executing \"%s\" in directory %s" % (command, cwd))
		else:
			print("Executing \"%s\"" % command)

		p = subprocess.Popen(command,
				cwd = cwd,
				encoding = "utf8",
				stdout = subprocess.PIPE,
				stderr = subprocess.STDOUT,
				shell = True)

		endTime = time.time() + timeout
		delay = 2

		while p.returncode is None:
			if time.time() > endTime:
				progress.finish("timed out.")
				p.kill()
				output, error = p.communicate()
				return ExecStatus.timedOut(str(output) + str(error))
			try:
				p.wait(delay)
			except subprocess.TimeoutExpired as e:
				progress.tick()

			delay = 0.5

		progress.finish("done.")

		return ExecStatus.exited(p.returncode, p.stdout.read())

class InstanceConfig:
	def __init__(self, name, status = None):
		self.name = name
		self.platform = None
		self.image = None
		self.keyfile = None
		self.repositories = []
		self.install = []
		self.start = []
		self.features = []

	def enableRepositories(self, repo_names):
		for name in repo_names:
			repo = self.platform.getRepository(name)
			if repo is None:
				raise ValueError("instance %s wants to use repository %s, but platform %s does not define it" % (
							self.name, name, self.platform.name))

			if repo not in self.repositories:
				self.repositories.append(repo)

	def installPackages(self, package_list):
		for name in package_list:
			if name not in self.install:
				self.install.append(name)

	def startServices(self, service_list):
		for name in service_list:
			if name not in self.start:
				self.start.append(name)

	def enableFeatures(self, name_list):
		self.features += name_list

	def processTemplate(self, templatePath, outputPath, extraCommands = []):
		print("Creating %s from %s" % (outputPath, templatePath))

		data = self.asDict()

		data['COMMANDS'] += extraCommands

		tmpf = open(templatePath, "r")
		outf = open(outputPath, "w")

		lineNumber = 0
		for line in tmpf.readlines():
			lineNumber += 1

			output = ""
			while '@' in line:
				i = line.index('@')
				output += line[:i]

				line = line[i+1:]
				i = line.find('@')
				if i < 0:
					raise ValueError("lone @ in %s:%d" % (templatePath, lineNumber))

				if i == 0:
					# @@ is written out as @
					output += '@'
				else:
					key = line[:i]

					value = data.get(key)
					if value is None:
						raise ValueError("%s:%s: unknown key \"%s\"" % (templatePath, lineNumber, key))

					if type(value) == list:
						if len(value) == 0:
							debug("%s:%s: key %s expands to empty list" % (templatePath, lineNumber, key))
							value = ""
						else:
							for l in value[:-1]:
								outf.write(output + l + "\n")
							value = value[-1]

					output += value

				line = line[i+1:]

			output += line
			outf.write(output)

	def asDict(self, list_sepa = " "):
		d = {}

		d['NAME'] = self.name
		d['HOSTNAME'] = self.name
		d['PLATFORM'] = self.platform.name
		d['IMAGE'] = self.image or ""
		d['KEYFILE'] = self.keyfile or ""
		d['REPOSITORIES'] = list_sepa.join(repo.url for repo in self.repositories)
		d['INSTALL'] = list_sepa.join(self.install)
		d['START'] = list_sepa.join(self.start)

		# FIXME: should we manually install the package signing keys?
		# We could download them from $url/repodata/repomd.xml.key
		# and have the config refer to the file...

		cmdlist = []
		for repo in self.repositories:
			if repo.keyfile:
				# FIXME: upload the keyfile to the backend, and issue an
				# "rpm --import keyfile" command
				keyfile = repo.keyfile
			else:
				keyfile = "%s/repodata/repomd.xml.key" % repo.url

			if keyfile.startswith("http:") or keyfile.startswith("https:"):
				cmdlist.append("rpm --import " + keyfile)
			else:
				raise NotImplementedError("Cannot upload keyfile to instance")

			cmdlist.append("zypper ar %s %s" % (repo.url, repo.name))
		d['ADD_REPOSITORIES'] = cmdlist

		if self.install:
			d['INSTALL_PACKAGES'] = "zypper in -y " + " ".join(self.install)
		else:
			d['INSTALL_PACKAGES'] = ""

		d['COMMANDS'] = []

		return d

class TopologyStatus:
	class NodeStatus:
		def __init__(self, config):
			self._config = config
			self.name = config.name()
			self._ipv4_address = config.get_value("ipv4_address")
			self._ipv6_address = config.get_value("ipv6_address")
			self._features = config.get_values("features")

		@property
		def ipv4_address(self):
			return self._ipv4_address

		@ipv4_address.setter
		def ipv4_address(self, value):
			if self._ipv4_address != value:
				self._config.set_value("ipv4_address", value)
				self._ipv4_address = value

		@property
		def ipv6_address(self):
			return self._ipv6_address

		@ipv6_address.setter
		def ipv6_address(self, value):
			if self._ipv6_address != value:
				self._config.set_value("ipv6_address", value)
				self._ipv6_address = value

		def clearNetwork(self):
			self.ipv4_address = None
			self.ipv6_address = None

		def set_value(self, name, value):
			self._config.set_value(name, value)

		def set_features(self, names):
			self._features = names
			self._config.set_value('features', names)

	def __init__(self, pathname):
		self.path = pathname

		if self.path.startswith("~"):
			raise ConfigError("Invalid status path \"%s\"" % self.path)

		# If the status file exists, read it. Otherwise
		# start with an empty status object
		if self.path and os.path.exists(self.path):
			self._load()
		else:
			self.data = curly.Config()
			self.tree = self.data.tree()

			self._backend = None
			self._testcase = None
			self._nodes = {}

		self.tree = self.data.tree()

	def _load(self):
		self.data = curly.Config(self.path)
		debug("Loaded status from %s" % self.path)

		self.tree = self.data.tree()

		self._backend = self.tree.get_value("backend")
		self._testcase = self.tree.get_value("testcase")
		self._workspace = self.tree.get_value("workspace")

		self._nodes = {}
		for name in self.tree.get_children("node"):
			self._nodes[name] = self.NodeStatus(self.tree.get_child("node", name))

	@property
	def backend(self):
		return self._backend

	@backend.setter
	def backend(self, value):
		if self._backend != value:
			self.tree.set_value("backend", value)
			self._backend = value

	@property
	def testcase(self):
		return self._testcase

	@testcase.setter
	def testcase(self, value):
		if self._testcase != value:
			self.tree.set_value("testcase", value)
			self._testcase = value

	@property
	def workspace(self):
		return self._workspace

	@workspace.setter
	def workspace(self, value):
		if self._workspace != value:
			self.tree.set_value("workspace", value)
			self._workspace = value

	@property
	def nodes(self):
		return self._nodes.values()

	def getNodeState(self, name, create = False):
		node = self._nodes.get(name)
		if node is None and create:
			node = self.NodeStatus(self.tree.add_child("node", name))
			self._nodes[name] = node
		return node

	def createNodeState(self, name):
		return self.getNodeState(name, create = True)

	def dropNode(self, node):
		debug("dropping status for node %s" % node.name)
		if self.tree.drop_child(node._config) == 0:
			print("drop_child(%s) failed" % node)

		try:
			del self._nodes[node.name]
		except: pass

	def save(self):
		if not self.path:
			raise ValueError("%s: cannot save data, pathname not set" % self.__class__.__name__)

		parent_dir = os.path.dirname(self.path)
		if parent_dir and not os.path.isdir(parent_dir):
			debug("Creating directory %s" % parent_dir)
			os.makedirs(parent_dir)

		debug("Saving status to %s" % self.path)
		self.data.save(self.path)

		if False:
			print("-- contents of %s --" % self.path)
			os.system("cat %s" % self.path)
			print("-- END of contents --")

	def remove(self):
		if self.path and os.path.exists(self.path):
			os.remove(self.path)


class TestTopology:
	class Repository(Configurable):
		def __init__(self, name):
			self.name = name
			self.url = None
			self.keyfile = None

		def configure(self, config):
			if not config:
				return

			self.update_value(config, 'url')

	class Platform(Configurable):
		def __init__(self, name):
			self.name = name
			self.image = None
			self.keyfile = None
			self.repositories = {}
			self.features = []

		def configure(self, config):
			if not config:
				return

			self.update_value(config, 'image')
			self.update_value(config, 'keyfile')
			self.update_value(config, 'keyfile', 'ssh-keyfile')
			self.update_list(config, 'features')

			for name in config.get_children("repository"):
				child = config.get_child("repository", name)

				repo = self.createRepository(name)
				repo.configure(child)

				# print("Platform %s provides repo %s at %s" % (self.name, repo.name, repo.url))

		def getRepository(self, name):
			return self.repositories.get(name)

		def createRepository(self, name):
			repo = self.repositories.get(name)
			if repo is None:
				repo = TestTopology.Repository(name)
				self.repositories[name] = repo
			return repo

	class Role(Configurable):
		def __init__(self, name):
			self.name = name
			self.platform = None

			self.repositories = []
			self.install = []
			self.start = []
			self.features = []

		def configure(self, config):
			if not config:
				return

			self.update_value(config, 'platform')
			self.update_list(config, 'repositories')
			self.update_list(config, 'install')
			self.update_list(config, 'start')
			self.update_list(config, 'features')

	class Node(Configurable):
		def __init__(self, name):
			self.name = name
			self.role = name
			self.install = []
			self.start = []

		def configure(self, config):
			if not config:
				return

			self.update_value(config, 'role')
			self.update_list(config, 'install')
			self.update_list(config, 'start')

	def __init__(self, backend, workspace = None):
		self.backend = None
		self.workspace = workspace

		self.platforms = {}
		self.roles = {}
		self.nodes = {}
		self.repositories = []
		self.testcase = None
		self.workspaceRoot = None
		self.platform = None
		self.persistentState = None
		self.persistentStatePath = None
		self.defaultRole = self.createRole("default")

		self.instanceConfigs = []
		self.instances = []

		self.postponedBackendConfigs = []

		if backend:
			self.setBackend(backend)

		self._valid = False

	def loadConfig(self, filename):
		if not os.path.exists(filename):
			return

		config = curly.Config(filename)

		tree = config.tree()

		self.platformsFromConfig(tree)
		self.rolesFromConfig(tree)
		self.nodesFromConfig(tree)

		workspaceRoot = tree.get_value('workspace-root')
		if workspaceRoot:
			self.workspaceRoot = workspaceRoot

		workspace = tree.get_value('workspace')
		if workspace:
			self.workspace = workspace

		testcase = tree.get_value('testcase')
		if testcase:
			self.testcase = testcase

		if self.backend:
			child = tree.get_child("backend", self.backend.name)
			if child:
				self.backend.configure(child)
		else:
			self.postponedBackendConfigs.append(tree)

	def setBackend(self, backend):
		assert(self.backend is None)

		for config in self.postponedBackendConfigs:
			child = config.get_child("backend", backend.name)
			if child:
				backend.configure(config)
		self.postponedBackendConfigs = []

		self.backend = backend

	def setStatusPath(self, pathname):
		self.persistentStatePath = pathname

	def loadStatus(self):
		if not self.persistentState:
			path = self.persistentStatePath
			if path is None:
				path = os.path.join(self.workspace, "status.conf")
			self.persistentState = TopologyStatus(path)
		return self.persistentState

	def saveStatus(self):
		if self.persistentState:
			self.persistentState.backend = self.backend.name
			self.persistentState.testcase = self.testcase

			# This is not ideal, because we're polluting the workspace
			# used for managing the VMs with other files, such as
			# logs or formatted test reports.
			if False:
				runPath = os.path.join(self.workspace, "run")
				if not os.path.isdir(runPath):
					os.makedirs(runPath)
				self.persistentState.workspace = runPath

			self.persistentState.save()

	def cleanupStatus(self):
		if self.persistentState:
			self.persistentState.remove()

	def validateConfig(self):
		if self._valid:
			return

		if not self.testcase:
			raise ConfigError("no testcase name configured")

		if not self.workspace and self.workspaceRoot:
			self.workspace = os.path.join(self.workspaceRoot, self.testcase, time.strftime("%Y%m%dT%H%M%S"))

		if not self.workspace:
			raise ConfigError("no workspace configured")

		if not os.path.isdir(self.workspace):
			os.makedirs(self.workspace)

		status = self.loadStatus()

		status.backend = self.backend.name
		status.testcase = self.testcase
		status.save()

		for node in self.nodes.values():
			self.createInstanceConfig(node)

		self._valid = True

	def loadNodeFile(self, nodepath):
		instances = []

		f = susetest.NodesFile(nodepath)
		for oldNode in f.nodes:
			node = self.createNode(oldNode.name)
			if oldNode.role:
				node.role = oldNode.role

			node.install = oldNode.installPackages

		if not self.testcase:
			w = nodepath.split('/')
			while w:
				name = w.pop()
				if not name or name == 'nodes' or name == 'twopence':
					continue

				if name.startswith("twopence-"):
					name = name[9:]

				self.testcase = name

		return

	def setupRepositories(self, repositories):
		if not repositories:
			return # [] or None

		for url in repositories:
			self.repositories.append(url)

	def hasRunningInstances(self):
		return any(i.running for i in self.instances)

	def detect(self, detectNetwork = False):
		self.instances = []

		status = self.loadStatus()

		if self.backend is None:
			backendName = status.backend
			if backendName is None:
				return

			verbose("Detected backend %s" % backendName)
			self.setBackend(Backend.create(backendName))

		if self.testcase is None:
			self.testcase = status.testcase
			if self.testcase is None:
				return

			debug("Detected testcase %s" % self.testcase)

		self.validateConfig()

		self.instances = self.backend.detect(self.workspace, self.persistentState, self.instanceConfigs)

		return self.instances

	def prepare(self):
		assert(not self.instances)

		self.validateConfig()
		self.saveStatus()

		success = True
		for instanceConfig in self.instanceConfigs:
			instance = self.backend.prepareInstance(self.workspace, instanceConfig,
						self.persistentState.createNodeState(instanceConfig.name))
			if instance.exists:
				print("Ouch, instance %s seems to exist" % instance.name)
				success = False

			self.instances.append(instance)

		self.saveStatus()
		return success

	def start(self, okayIfRunning = False):
		self.validateConfig()

		if any(i.exists for i in self.instances):
			print("Refusing to start; please clean up any existing instances first");
			return False

		success = True
		for instance in self.instances:
			if instance.running:
				if not okayIfRunning:
					raise ValueRrror("Instance %s already running" % instance.name)
				continue

			if verbose_enabled():
				verbose("  Image %s, SSH keyfile %s" % (instance.config.image, instance.config.keyfile))
				if instance.config.install:
					verbose("  Installing package(s):")
					for name in instance.config.install:
						verbose("        %s" % name)
				if instance.config.start:
					verbose("  Starting service(s):")
					for name in instance.config.start:
						verbose("        %s" % name)

			if not instance.persistent:
				print("Oops, no persistent state for %s?!" % instance.name)
				fail

			try:
				success = self.backend.startInstance(instance)
			except Exception as e:
				print("Caught exception while trying to start instance: %s" % e)
				success = False

			if not success:
				print("Failed to start instance %s" % instance.name)
				break

			instance.exists = True

			self.backend.updateInstanceTarget(instance)

			self.saveStatus()

		return success

	def stop(self, **kwargs):
		self.validateConfig()

		for instance in self.instances:
			self.backend.stopInstance(instance, **kwargs)
			self.backend.updateInstanceTarget(instance)

			self.saveStatus()

	def destroy(self):
		for instance in self.instances:
			self.backend.destroyInstance(instance)

			if instance.persistent:
				self.persistentState.dropNode(instance.persistent)
				instance.persistent = None

			self.saveStatus()
		self.instances = []

	def cleanup(self):
		self.cleanupStatus()

		# Do not try to remove the workspace; it contains the BOM file
		# and possibly copies of some config files

	def createInstanceConfig(self, node):
		result = InstanceConfig(node.name)

		role = self.getRole(node.role)

		result.platform = self._platformForRole(node.role)
		result.image = result.platform.image
		result.keyfile = result.platform.keyfile

		result.installPackages(node.install)
		result.startServices(node.start)
		result.enableFeatures(result.platform.features)

		if role:
			result.enableRepositories(role.repositories)
			result.installPackages(role.install)
			result.enableFeatures(role.features)

		result.enableRepositories(self.defaultRole.repositories)
		result.installPackages(self.defaultRole.install)
		result.enableFeatures(self.defaultRole.features)

		self.instanceConfigs.append(result)
		return result

	def _platformForRole(self, roleName):
		role = self.getRole(roleName)
		if role and role.platform:
			platform = self.getPlatform(role.platform)
			if platform:
				return platform

			raise ValueError("Cannot find platform \"%s\" for role \"%s\"" % (role.platform, node.role))

		if self.defaultRole.platform:
			platform = self.getPlatform(self.defaultRole.platform)
			if platform:
				return platform

			raise ValueError("Cannot find platform \"%s\" for default role" % (self.defaultRole.platform))

		raise ValueError("No platform defined for role \"%s\"" % roleName)

	def platformsFromConfig(self, tree):
		for name in tree.get_children("platform"):
			platform = self.createPlatform(name)

			child = tree.get_child("platform", name)
			platform.configure(child)

			debug("Defined platform %s image=%s key=%s" % (platform.name,
				platform.image, platform.keyfile))

	def rolesFromConfig(self, tree):
		for name in tree.get_children("role"):
			child = tree.get_child("role", name)

			role = self.createRole(name)
			role.configure(child)

			debug("Defined role %s platform=%s repos=%s" % (role.name,
				role.platform, role.repositories))

	def nodesFromConfig(self, tree):
		for name in tree.get_children("node"):
			child = tree.get_child("node", name)

			node = self.createNode(name)
			node.configure(child)

	def getPlatform(self, name):
		return self.platforms.get(name)

	def createPlatform(self, name):
		platform = self.platforms.get(name)
		if platform is None:
			platform = self.Platform(name)
			self.platforms[name] = platform
		return platform

	def getRole(self, name):
		return self.roles.get(name)

	def createRole(self, name):
		role = self.roles.get(name)
		if role is None:
			role = self.Role(name)
			self.roles[name] = role
		return role

	def getNode(self, name):
		return self.nodes.get(name)

	def createNode(self, name):
		node = self.nodes.get(name)
		if node is None:
			node = self.Node(name)
			self.nodes[name] = node
		return node

class BOM:
	def __init__(self, workspace):
		self.workspace = workspace
		self.backend = None
		self.status = None
		self.config = []

		self._saveConfigs = False
		self._path = os.path.join(workspace, "bom.conf")

	@property
	def path(self):
		return self._path

	@property
	def exists(self):
		return os.path.exists(self._path)

	def load(self):
		self.data = curly.Config(self._path)
		debug("Loaded status from %s" % self.path)

		tree = self.data.tree()

		self.backend = tree.get_value("backend")
		self.status = tree.get_value("status")
		self.logspace = tree.get_value("logspace")
		self.config = tree.get_values("config")

		return True

	def addConfig(self, path):
		if self._saveConfigs:
			path = self.saveConfig(path)
		else:
			path = os.path.realpath(path)
		self.config.append(path)

	def saveConfig(self, path):
		import shutil

		if not os.path.isdir(self.workspace):
			os.makedirs(self.workspace)

		copied = os.path.join(self.workspace, os.path.basename(path))
		shutil.copyfile(path, copied)

		return copied

	def save(self):
		bom = curly.Config()
		tree = bom.tree()

		if not self.status:
			self.status = os.path.join(self.workspace, "status.conf")
		if not self.logspace:
			self.logspace = os.path.join(self.workspace, "run")

		tree.set_value("backend", self.backend)
		tree.set_value("status", self.status)
		tree.set_value("logspace", self.logspace)
		tree.set_value("config", self.config)

		if not os.path.isdir(self.workspace):
			os.makedirs(self.workspace)

		bom.save(self._path)

def action_help(args):
	parser.print_help()
	exit(0)

def create_topology(args):
	bom = BOM(args.workspace)

	if not bom.load():
		raise ValueError("Failed to load BOM from %s" % bom.path)

	print("Loaded BOM: backend=%s config=%s" % (bom.backend, bom.config))

	backend = Backend.create(bom.backend)

	topology = TestTopology(backend, workspace = args.workspace)

	load_config(topology, bom)

	topology.validateConfig()

	return topology

def load_config(topology, bom):
	for path in global_config_paths:
		topology.loadConfig(path)

	for configPath in bom.config:
		if configPath.startswith('nodes:'):
			# parse an old-style nodes file
			topology.loadNodeFile(configPath[6:])
		else:
			topology.loadConfig(configPath)

	if bom.status:
		topology.setStatusPath(args.status)

def action_init(args):
	workspace = args.workspace

	bom = BOM(args.workspace)

	if bom.exists:
		print("BOM file %s seems to exist, refusing to initialize" % bom.path)
		exit(1)

	bom.backend = args.backend
	bom.logspace = args.logspace
	for path in args.config:
		bom.addConfig(path)

	bom.save()

	try:
		topology = create_topology(bom)
	except ConfigError as e:
		print("Error: the resulting configuration is not valid")
		print(e)
		exit(2)

def action_create(args):
	topology = create_topology(args)
	if topology.detect():
		print("One or more VMs seem to exist.")
		for instance in topology.instances:
			print("  %s" % instance.name)

		if not args.auto_destroy:
			print("Please destroy these instances first, or invoke this command with --auto-destroy")
			exit(1)

		verbose("Auto-destroying these instances NOW")
		topology.stop(destroy = True)

		topology.detect()
		if topology.hasRunningInstances():
			print("Cannot stop all VMs - giving up")
			exit(1)

		topology.destroy()
		topology.cleanup()

	if not topology.prepare():
		print("Unable to prepare all instances")
		exit(1)

	topology.start()

def action_destroy(args):
	topology = create_topology(args)
	if not topology.detect():
		verbose("Nothing to destroy")
	else:
		print("Detected running instance(s):")
		for instance in topology.instances:
			print("  %s" % instance.name)

		verbose("Destroying these instances")
		topology.stop()

		topology.detect()
		if topology.hasRunningInstances():
			print("Cannot stop all VMs - giving up")
			exit(1)

	topology.destroy()
	topology.cleanup()

def action_status(args):
	topology = create_topology(args)
	if not topology.detect(detectNetwork = True):
		verbose("No instances")
	else:
		print("Detected instance(s) for testcase %s:" % topology.testcase)
		for instance in topology.instances:
			addresses = []
			for nif in instance.networkInterfaces:
				addresses.append(str(nif))

			if addresses:
				address = addresses.pop(0)
			else:
				address = ''

			print("  %-20s %-10s %s" % (instance.name,
					instance.running and "running" or "stopped",
					address))

			while addresses:
				address = addresses.pop(0)
				print(" %*.32s %s" % ('', address))

def action_show(args):
	topology = create_topology(args)
	for type in args.info_type:
		if type == 'status-file':
			st = topology.loadStatus()
			print(st.path or "")
		else:
			raise ValueError("Unsupported info-type \"%s\"" % type)

def build_arg_parser():
	import argparse

	parser = argparse.ArgumentParser(description = 'Provision test instances.')
	parser.add_argument('--workspace',
			    help = 'the directory to use as workspace')
	parser.add_argument('--quiet', default = False, action = 'store_true',
			    help = 'Disable most output')
	parser.add_argument('--status',
			    help = 'path to the file to store status info [default $workspace/status.conf]')
	parser.add_argument('--debug', default = False, action = 'store_true',
			    help = 'Enable debug output')

	sub = parser.add_subparsers(dest = 'command')

	sp = sub.add_parser('init', help = 'Initialize a run')
	sp.set_defaults(action = action_init)
	sp.add_argument('--config', action = 'append',
			help='path to the file describing the nodes to be provisioned')
	sp.add_argument('--backend', default = 'vagrant',
			help = 'the provisioning backend to use [vagrant]')
	sp.add_argument('--logspace',
			help = 'the default location for test runs to write their log files to')

	sp = sub.add_parser('create', help = 'Create the requested nodes')
	sp.set_defaults(action = action_create)
	sp.add_argument('--backend', default = 'vagrant',
			help = 'the provisioning backend to use [vagrant]')
	sp.add_argument('--auto-destroy', default = False, action = 'store_true',
			help = 'if one or more of the requested nodes are running, destroy them')

	sp = sub.add_parser('destroy', help = 'Destroy the topology')
	sp.set_defaults(action = action_destroy)

	sp = sub.add_parser('status', help = 'Display status on the topology')
	sp.set_defaults(action = action_status)

	sp = sub.add_parser('show', help = 'Display info on the test case')
	sp.set_defaults(action = action_show)
	sp.add_argument('info_type', metavar='INFO-TYPE', nargs = '+',
			help='info type to display (status-file, ...)')

	sp = sub.add_parser('help', help = 'Print this message')
	sp.set_defaults(action = action_help)

	return parser


parser = build_arg_parser()
args = parser.parse_args()

if args.debug:
	opt_verbose = 2
elif not args.quiet:
	opt_verbose = 1
else:
	opt_verbose = 0

if not args.command:
	print("Error: missing subcommand")
	parser.print_help()
	exit(2)

if args.workspace is None:
	print("Error: missing --workspace option")
	parser.print_help()
	exit(2)

args.action(args)
