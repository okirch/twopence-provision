#!/usr/bin/python3
##################################################################
#
# Main twopence provisioner script
#
# Copyright (C) 2021 Olaf Kirch <okir@suse.de>
#
##################################################################

import sys
import os
from twopence.provision import *
from twopence.provision.topology import TopologyStatus
from twopence.provision.paths import *

global_config_files	= [
	"twopence.conf",
	"provision.conf",
]

class BasicAction(object):
	def __init__(self, args):
		self.args = args
		self._backend = None
		self._config = None

	def loadEmptyConfig(self):
		if self._config is None:
			config = Config(None)
			for path in global_config_files:
				config.load(path)
			config.addDirectory(twopence_user_config_dir)
			self._config = config

		return self._config

class Action(BasicAction):
	def __init__(self, args):
		super().__init__(args)

		if args.workspace is None:
			print("Error: missing --workspace option")
			parser.print_help()
			exit(2)

		self.workspace = args.workspace
		self.auto_destroy = False

		self._bom = None

		self._auto_update_images = not args.no_auto_update_images

	def error(self, msg):
		print("Error: " + msg, file = sys.stderr)

	def fatal(self, msg):
		print("FATAL: " + msg, file = sys.stderr)
		exit(1)

	@property
	def bom(self):
		if self._bom is None:
			bom = BOM(self.workspace)
			if not bom.load():
				raise ValueError("Failed to load BOM from %s" % bom.path)

			self._bom = bom
		return self._bom

	@property
	def backend(self):
		if self._backend is None:
			bom = self.bom
			self._backend = Backend.create(bom.backend)

			if not self._auto_update_images:
				self._backend.auto_update = False
		return self._backend

	def loadConfig(self, purpose = None):
		if self._config:
			return self._config

		bom = self.bom

		config = Config(bom.workspace)
		config.status = bom.status
		config.logspace = bom.logspace

		for path in global_config_files:
			config.load(path)

		# Note: we load global config files first; THEN
		# we add user directories to the config search path.
		config.addDirectory(twopence_user_config_dir)

		for path in bom.config:
			config.load(path)

		if purpose:
			config.validate(purpose = purpose)

		config.requirementsManager = RequirementsPrompter(config)

		self._config = config
		return config

	def validateConfig(self, config, purpose):
		config.validate(purpose = purpose)

	def createTopology(self, purpose = None):
		backend = self.backend
		config = self.loadConfig(purpose)

		config.validate(purpose = purpose)

		return TestTopology(backend, config = config, workspace = self.workspace)

	def provisionTopology(self, topology):
		if topology.detect():
			print("One or more VMs seem to exist.")
			for instance in topology.instances:
				print("  %s" % instance.name)

			if not self.auto_destroy:
				self.fatal("Please destroy these instances first, or invoke this command with --auto-destroy")

			verbose("Auto-destroying these instances NOW")
			self.shutdownTopology(topology)
			self.destroyTopology(topology)

		if not topology.prepare():
			self.fatal("Unable to prepare all instances")

		if not topology.start():
			self.fatal("Unable to start instance(s)")

	def shutdownTopology(self, topology):
		verbose("Stopping all instances")
		topology.stop()
		topology.detect()
		if topology.hasRunningInstances():
			self.fatal("Cannot stop all VMs - giving up")

	def destroyTopology(self, topology):
		topology.destroy()
		topology.cleanup()

	def zapWorkspace(self, force = False):
		import os
		import shutil

		bom = self.bom

		empty = True
		for entry in os.scandir(args.workspace):
			if entry.path != bom.path:
				if not force:
					if entry.is_dir():
						self.error("workspace contains directory %s" % entry.path)
					else:
						self.error("workspace contains file %s" % entry.path)
					empty = False
				else:
					if entry.is_dir():
						verbose("Removing directory %s" % entry.path)
						shutil.rmtree(entry.path)
					else:
						verbose("Removing file %s" % entry.path)
						os.remove(entry.path)

		if not empty:
			self.fatal("cannot zap workspace, not empty")

		verbose("Removing %s" % bom.path)
		bom.remove()
		os.rmdir(args.workspace)
		verbose("Removed workspace %s" % args.workspace)

class ActionHelp(Action):
	def perform(self):
		parser.print_help()
		exit(0)

class ActionInit(Action):
	def __init__(self, args):
		super().__init__(args)

		self._backend = args.backend
		self._logspace = args.logspace
		self._configs = args.config

	def perform(self):
		bom = BOM(self.workspace)
		if bom.exists:
			self.fatal("BOM file %s seems to exist, refusing to initialize" % bom.path)
		self._bom = bom

		bom.backend = self._backend
		bom.logspace = self._logspace
		for path in self._configs:
			bom.addConfig(path)

		bom.save()

		try:
			config = self.loadConfig(purpose = "init")
		except ConfigError as e:
			print("Error: the resulting configuration is not valid")
			print(e)
			exit(2)

		return

class ActionBuild(Action):
	def __init__(self, args):
		super().__init__(args)

		self.auto_destroy = args.auto_destroy

		if not args.base_platform:
			self.fatal("Missing --base-platform")
		self.base_platform = args.base_platform

		self.features = args.feature

		if not args.target:
			self.fatal("Missing argument: name of target build")
		self.target = args.target

	def displayBuildOrPlatform(self, desc, p, indent = ""):
		print("%s%s = %s" % (indent, desc, p))

		indent += "  "
		for stage in p.stages.values():
			print("%sStage %s%s" % (indent, stage.name, stage.reboot and " (reboot)" or ""))
			for script in stage.run:
				print("%s  run %s" % (indent, script))

	def perform(self):
		bom = self.bom

		config = self.loadConfig(purpose = None)

		base_platform = config.getPlatform(self.base_platform)

		if False:
			self.displayBuildOrPlatform("base platform", base_platform)
			for name in self.features:
				self.displayBuildOrPlatform("build", config.getBuild(name))

		buildNode = config.createNode("build")
		buildNode.platform = self.base_platform
		buildNode.build = self.features

		config.validate(purpose = "building")

		# FIXME: hack
		config.testcase = "build"

		topology = TestTopology(self.backend, config = config, workspace = self.workspace)

		# This provisions the build node - and with that, we're already done,
		# so we can take it down right away.
		# A nicer approach would be to separate the build steps from actual
		# provisioning steps, but that's for the future.
		self.provisionTopology(topology)
		self.shutdownTopology(topology)

		# Now package up the image and all the ancillary information, like
		# ssh keys and the platform .config file describing the result.
		topology.package(buildNode.name, self.target)

		self.destroyTopology(topology)

class ActionCreate(Action):
	def __init__(self, args):
		super().__init__(args)
		self.auto_destroy = args.auto_destroy

	def perform(self):
		topology = self.createTopology(purpose = "testing")
		self.provisionTopology(topology)

class ActionDestroy(Action):
	def __init__(self, args):
		super().__init__(args)
		self.zap = args.zap
		self.force = args.force

	def perform(self):
		topology = self.createTopology(purpose = "destroy")
		if not topology.detect():
			verbose("Nothing to destroy")
		else:
			print("Detected running instance(s):")
			for instance in topology.instances:
				print("  %s" % instance.name)

			self.shutdownTopology(topology)

		self.destroyTopology(topology)

		if self.zap:
			self.zapWorkspace(force = self.force)

class ActionStatus(Action):
	def perform(self):
		topology = self.createTopology(purpose = None)
		if not topology.detect(detectNetwork = True):
			verbose("No instances")
		else:
			print("Detected instance(s) for testcase %s:" % topology.testcase)
			for instance in topology.instances:
				addresses = []
				for nif in instance.networkInterfaces:
					addresses.append(str(nif))

				if addresses:
					address = addresses.pop(0)
				else:
					address = ''

				print("  %-20s %-10s %s" % (instance.name,
						instance.running and "running" or "stopped",
						address))

				while addresses:
					address = addresses.pop(0)
					print(" %*.32s %s" % ('', address))

class ActionShow(Action):
	def __init__(self, args):
		super().__init__(args)

		self.info_types = args.info_type

	def perform(self):
		topology = self.createTopology(purpose = None)
		for type in self.info_types:
			if type == 'status-file':
				st = topology.persistentState
				print(st.path or "")
			else:
				raise ValueError("Unsupported info-type \"%s\"" % type)

class ActionLogin(Action):
	def __init__(self, args):
		super().__init__(args)

		if len(args.node) != 1:
			raise ValueError("Unexpected number of arguments")

		self.node = args.node[0]
		self.use_ipv4 = None
		self.use_ipv6 = None

	def perform(self):
		config = self.loadConfig(purpose = "login")

		print(config.status)
		if not config.status:
			raise ValueError("no status.conf file found in workspace %s", args.workspace)

		status = TopologyStatus(config.status)
		node = status.getNodeState(self.node)

		if self.use_ipv4:
			address = node.ipv4_address
		elif self.use_ipv6:
			address = node.ipv6_address
		else:
			address = node.ipv4_address or node.ipv6_address

		# The backend should really store the name of the default
		# account in status.conf
		user = None
		if status.backend == 'vagrant':
			user = 'vagrant'

		if not user:
			raise ValueError("Unable to determine login user name")

		command = ["ssh",
			# Do not pollute the user's .known_hosts file with address/key pairs that
			# will change all the time, anyway
			"-o", "UserKnownHostsFile=/dev/null",
			# And don't ask about saving host keys to /dev/null ...
			"-o", "StrictHostKeyChecking=no",
			]
		if node.keyfile:
			command += ["-i", node.keyfile]


		command.append("%s@%s" % (user, address))

		cmdline = " ".join(command)
		print("Now connect to %s" % address)
		print("  %s" % cmdline)
		os.system(cmdline)

class ActionPlatform(BasicAction):
	def __init__(self, args):
		super().__init__(args)
		self._requirements = {}

	def perform(self):
		config = self.loadEmptyConfig()

		all = []
		for info in config.locatePlatformFiles():
			for platform in info.platforms:
				all.append((platform, info))

		all = sorted(all, key = lambda pair: (pair[0].vendor, pair[0].os, pair[0].name))

		if not all:
			print("No platforms configured. Something is wrong.")
			return

		requires = set()
		backends = {}

		print()
		for platform, info in all:
			print("%s (%s)" % (platform.name, info.path))
			print("    Vendor/OS:      %s/%s" % (platform.vendor, platform.os))
			if platform.build_time:
				print("    Build time:     %s" % platform.build_time)
			self.showRequires(config, platform)
			if platform.features:
				print("    Features:       %s" % ", ".join(platform.features))
			if platform.install:
				print("    Install pkgs:   %s" % ", ".join(platform.install))
			if platform.start:
				print("    Start svcs:     %s" % ", ".join(platform.start))

			if info.builds:
				print()
				print("    Build options")
			for build in info.builds:
				print("      - %s" % build.name)
				if build.features:
					print("        Provides:       %s" % ", ".join(build.features))
				if build.requires:
					print("    Requires:       %s" % ", ".join(build.requires))
				for name in platform.requires:
					requires.add(name)

			if platform.backends:
				# We could print per-backend image/key information here
				# If we want to get super smart, we could even display image version
				# (upstream and local).
				print()
				print("    Backends")
				for backendInfo in platform.backends.values():
					backend = backends.get(backendInfo.name)
					if backend is None:
						backend = Backend.create(backendInfo.name)
						backends[backendInfo.name] = backend
					print("      - %s" % backend.name)
					for name, value in backend.renderPlatformInformation(backendInfo):
						print("        %-12s %s" % (name.capitalize(), value))

			for name in platform.requires:
				requires.add(name)

			print()

		if requires:
			print()
			print("Detected requirement(s): %s" % ", ".join(requires))
			for name in requires:
				path = config.locateConfig("%s.conf" % name)
				if path is None:
					print("  %s: not provided by any config file; please create %s/%s.conf" % (
							name, twopence_user_data_dir, name))
				else:
					print("  %s: provided by %s" % (name, path))

	# obj is Platform or Build
	def showRequires(self, config, obj):
		if obj.requires:
			print("    Requires:       %s" % ", ".join(obj.requires))
			for name in obj.requires:
				status = self._requirements.get(name)
				if status is None:
					path = config.locateConfig("%s.conf" % name)
					if path is None:
						status = "not provided by any config file; please create %s/%s.conf" % (
								twopence_user_data_dir, name)
					else:
						status = "provided by %s" % (path)
					self._requirements[name] = status
				print("    - %13s %s" % (name, status))

# FIXME: It might make sense to put the history loading into a utility class
# and share it across all of twopence/susetest
import readline
import atexit

class RequirementsPrompter(RequirementsManager):
	histfile = None
	h_len = None

	def __init__(self, config):
		super().__init__(config)

		self.loadHistory("~/.twopence/reqhistory")

	@classmethod
	def loadHistory(cls, path):
		if cls.h_len is not None:
			return

		cls.histfile = os.path.expanduser(path)
		try:
			readline.read_history_file(cls.histfile)
			cls.h_len = readline.get_current_history_length()
		except FileNotFoundError:
			open(cls.histfile, 'wb').close()
			cls.h_len = 0

		atexit.register(cls.saveHistory)

	@classmethod
	def saveHistory(cls):
		new_h_len = readline.get_current_history_length()
		readline.set_history_length(1000)
		readline.append_history_file(new_h_len - cls.h_len, cls.histfile)

	def prompt(self, nodeName, req):
		print("Node %s requires %s" % (nodeName, req.name))
		result = {}
		for name, prompt, default in req.prompt():
			if default:
				prompt += " [%s]" % default
			prompt += ": "

			try:
				response = input(prompt)
			except EOFError:
				print("<EOF>")
				print("Aborted by user")
				exit(42)

			response = response.strip()
			if not response and default is not None:
				response = default

			result[name] = response

		return result

def build_arg_parser():
	import argparse

	parser = argparse.ArgumentParser(description = 'Provision test instances.')
	parser.add_argument('--workspace',
			    help = 'the directory to use as workspace')
	parser.add_argument('--quiet', default = False, action = 'store_true',
			    help = 'Disable most output')
	parser.add_argument('--no-auto-update-images', default = False, action = 'store_true',
			    help = 'Do not update base images automatically (default for eg public vagrant images)')
	parser.add_argument('--status',
			    help = 'path to the file to store status info [default $workspace/status.conf]')
	parser.add_argument('--debug', default = False, action = 'store_true',
			    help = 'Enable debug output')

	sub = parser.add_subparsers(dest = 'command')

	sp = sub.add_parser('init', help = 'Initialize a run')
	sp.set_defaults(action = ActionInit)
	sp.add_argument('--config', action = 'append', default = [],
			help='path to the file describing the nodes to be provisioned')
	sp.add_argument('--backend', default = 'vagrant',
			help = 'the provisioning backend to use [vagrant]')
	sp.add_argument('--logspace',
			help = 'the default location for test runs to write their log files to')

	sp = sub.add_parser('build', help = 'Build a silver image')
	sp.set_defaults(action = ActionBuild)
	sp.add_argument('--auto-destroy', default = False, action = 'store_true',
			help = 'if one or more of the requested nodes are running, destroy them')
	sp.add_argument('--base-platform',
			help = 'the name of the base platform to use')
	sp.add_argument('--feature', action = 'append', default = [],
			help = 'build feature to select')
	sp.add_argument('target', metavar='TARGET', nargs='?',
			help = 'name of the target image to be built')

	sp = sub.add_parser('create', help = 'Create the requested nodes')
	sp.set_defaults(action = ActionCreate)
	sp.add_argument('--auto-destroy', default = False, action = 'store_true',
			help = 'if one or more of the requested nodes are running, destroy them')

	sp = sub.add_parser('destroy', help = 'Destroy the topology')
	sp.set_defaults(action = ActionDestroy)
	sp.add_argument('--zap', default = False, action = 'store_true',
			help = 'Remove the workspace as well, empty')
	sp.add_argument('--force', default = False, action = 'store_true',
			help = 'If used with --zap, remove the workspace and everything it contains')

	sp = sub.add_parser('status', help = 'Display status on the topology')
	sp.set_defaults(action = ActionStatus)

	sp = sub.add_parser('show', help = 'Display info on the test case')
	sp.set_defaults(action = ActionShow)
	sp.add_argument('info_type', metavar='INFO-TYPE', nargs = '+',
			help='info type to display (status-file, ...)')

	sp = sub.add_parser('login', help = 'Log into the indicated node')
	sp.set_defaults(action = ActionLogin)
	sp.add_argument('node', metavar='NODE-NAME', nargs = 1,
			help='the node name of the system to connect to')

	sp = sub.add_parser('platforms', help = 'Display information on available platforms')
	sp.set_defaults(action = ActionPlatform)

	sp = sub.add_parser('help', help = 'Print this message')
	sp.set_defaults(action = ActionHelp)

	return parser


parser = build_arg_parser()
args = parser.parse_args()

if args.debug:
	setVerbosity(2)
elif not args.quiet:
	setVerbosity(1)
else:
	setVerbosity(0)

if not args.command:
	print("Error: missing subcommand")
	parser.print_help()
	exit(2)

action = args.action(args)
action.perform()
