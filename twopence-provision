#!/usr/bin/python3
##################################################################
#
# Main twopence provisioner script
#
# Copyright (C) 2021 Olaf Kirch <okir@suse.de>
#
##################################################################

import sys
import os
from _twopence.provision import *
from _twopence.provision.topology import TopologyStatus

global_config_files	= [
	"twopence.conf",
	"provision.conf",
]

class Action:
	def __init__(self, args):
		if args.workspace is None:
			print("Error: missing --workspace option")
			parser.print_help()
			exit(2)

		self.args = args

		self.workspace = args.workspace
		self.auto_destroy = False

		self._bom = None
		self._backend = None
		self._config = None

	def error(self, msg):
		print("Error: " + msg, file = sys.stderr)

	def fatal(self, msg):
		print("FATAL: " + msg, file = sys.stderr)
		exit(1)

	@property
	def bom(self):
		if self._bom is None:
			bom = BOM(self.workspace)
			if not bom.load():
				raise ValueError("Failed to load BOM from %s" % bom.path)

			self._bom = bom
		return self._bom

	@property
	def backend(self):
		if self._backend is None:
			bom = self.bom
			self._backend = Backend.create(bom.backend)
		return self._backend

	def loadConfig(self, purpose = None):
		if self._config:
			return self._config

		bom = self.bom

		config = Config(bom.workspace)
		config.status = bom.status
		config.logspace = bom.logspace

		for path in global_config_files:
			config.load(path)

		# Note: we load global config files first; THEN
		# we add user directories to the config search path.
		config.addDirectory(twopence_user_config_dir)

		for path in bom.config:
			config.load(path)

		if purpose:
			config.validate(purpose = purpose)

		self._config = config
		return config

	def createTopology(self, purpose = None):
		bom = self.bom

		backend = self.backend
		config = self.loadConfig(purpose)

		config.validate(purpose = purpose)

		return TestTopology(backend, config = config, workspace = self.workspace)

	def provisionTopology(self, topology):
		if topology.detect():
			print("One or more VMs seem to exist.")
			for instance in topology.instances:
				print("  %s" % instance.name)

			if not self.auto_destroy:
				self.fatal("Please destroy these instances first, or invoke this command with --auto-destroy")

			verbose("Auto-destroying these instances NOW")
			self.shutdownTopology(topology)
			self.destroyTopology(topology)

		if not topology.prepare():
			self.fatal("Unable to prepare all instances")

		if not topology.start():
			self.fatal("Unable to start instance(s)")

	def shutdownTopology(self, topology):
		verbose("Stopping all instances")
		topology.stop()
		topology.detect()
		if topology.hasRunningInstances():
			self.fatal("Cannot stop all VMs - giving up")

	def destroyTopology(self, topology):
		topology.destroy()
		topology.cleanup()

	def zapWorkspace(self, force = False):
		import os
		import shutil

		bom = self.bom

		empty = True
		for entry in os.scandir(args.workspace):
			if entry.path != bom.path:
				if not force:
					if entry.is_dir():
						self.error("workspace contains directory %s" % entry.path)
					else:
						self.error("workspace contains file %s" % entry.path)
					empty = False
				else:
					if entry.is_dir():
						verbose("Removing directory %s" % entry.path)
						shutil.rmtree(entry.path)
					else:
						verbose("Removing file %s" % entry.path)
						os.remove(entry.path)

		if not empty:
			self.fatal("cannot zap workspace, not empty")

		verbose("Removing %s" % bom.path)
		bom.remove()
		os.rmdir(args.workspace)
		verbose("Removed workspace %s" % args.workspace)

class ActionHelp(Action):
	def perform(self):
		parser.print_help()
		exit(0)

class ActionInit(Action):
	def __init__(self, args):
		super().__init__(args)

		self._backend = args.backend
		self._logspace = args.logspace
		self._configs = args.config

	def perform(self):
		bom = BOM(self.workspace)
		if bom.exists:
			self.fatal("BOM file %s seems to exist, refusing to initialize" % bom.path)
		self._bom = bom

		bom.backend = self._backend
		bom.logspace = self._logspace
		for path in self._configs:
			bom.addConfig(path)

		bom.save()

		try:
			config = self.loadConfig(purpose = "init")
		except ConfigError as e:
			print("Error: the resulting configuration is not valid")
			print(e)
			exit(2)

		return

class ActionBuild(Action):
	def __init__(self, args):
		super().__init__(args)

		self.auto_destroy = args.auto_destroy
		if not args.target:
			self.fatal("Missing argument: name of target build")
		self.target = args.target

	def perform(self):
		bom = self.bom

		config = self.loadConfig(purpose = None)

		build_config = "/usr/lib/twopence/provision/%s/build.conf" % self.target
		if not config.load(build_config):
			raise ValueError("Cannot find %s" % build_config)

		config.validate(purpose = "building")

		buildNode = config.findBuildNode()
		if buildNode is None:
			raise ValueError("Cannot find the build node")

		build = config.getBuild(buildNode.build)
		if not build:
			raise ValueError("Cannot find a valid build description")

		verbose("Using %s" % build)

		# FIXME: hack
		config.testcase = "build"

		topology = TestTopology(self.backend, config = config, workspace = self.workspace)

		# This provisions the build node - and with that, we're already done,
		# so we can take it down right away.
		# A nicer approach would be to separate the build steps from actual
		# provisioning steps, but that's for the future.
		self.provisionTopology(topology)
		self.shutdownTopology(topology)

		# Now package up the image and all the ancillary information, like
		# ssh keys and the platform .config file describing the result.
		topology.package(buildNode.name)

		self.destroyTopology(topology)

class ActionCreate(Action):
	def __init__(self, args):
		super().__init__(args)
		self.auto_destroy = args.auto_destroy

	def perform(self):
		topology = self.createTopology(purpose = "testing")
		self.provisionTopology(topology)

class ActionDestroy(Action):
	def __init__(self, args):
		super().__init__(args)
		self.zap = args.zap
		self.force = args.force

	def perform(self):
		topology = self.createTopology(purpose = "testing")
		if not topology.detect():
			verbose("Nothing to destroy")
		else:
			print("Detected running instance(s):")
			for instance in topology.instances:
				print("  %s" % instance.name)

			self.shutdownTopology(topology)

		self.destroyTopology(topology)

		if self.zap:
			self.zapWorkspace(force = self.force)

class ActionStatus(Action):
	def perform(self):
		topology = self.createTopology(purpose = None)
		if not topology.detect(detectNetwork = True):
			verbose("No instances")
		else:
			print("Detected instance(s) for testcase %s:" % topology.testcase)
			for instance in topology.instances:
				addresses = []
				for nif in instance.networkInterfaces:
					addresses.append(str(nif))

				if addresses:
					address = addresses.pop(0)
				else:
					address = ''

				print("  %-20s %-10s %s" % (instance.name,
						instance.running and "running" or "stopped",
						address))

				while addresses:
					address = addresses.pop(0)
					print(" %*.32s %s" % ('', address))

class ActionShow(Action):
	def __init__(self, args):
		super().__init__(args)

		self.info_types = args.info_type

	def perform(self):
		topology = self.createTopology(purpose = None)
		for type in self.info_types:
			if type == 'status-file':
				st = topology.persistentState
				print(st.path or "")
			else:
				raise ValueError("Unsupported info-type \"%s\"" % type)

class ActionLogin(Action):
	def __init__(self, args):
		super().__init__(args)

		if len(args.node) != 1:
			raise ValueError("Unexpected number of arguments")

		self.node = args.node[0]
		self.use_ipv4 = None
		self.use_ipv6 = None

	def perform(self):
		config = self.loadConfig(purpose = "login")

		print(config.status)
		if not config.status:
			raise ValueError("no status.conf file found in workspace %s", args.workspace)

		status = TopologyStatus(config.status)
		node = status.getNodeState(self.node)

		if self.use_ipv4:
			address = node.ipv4_address
		elif self.use_ipv6:
			address = node.ipv6_address
		else:
			address = node.ipv4_address or node.ipv6_address

		# The backend should really store the name of the default
		# account in status.conf
		user = None
		if status.backend == 'vagrant':
			user = 'vagrant'

		if not user:
			raise ValueError("Unable to determine login user name")

		command = ["ssh",
			# Do not pollute the user's .known_hosts file with address/key pairs that
			# will change all the time, anyway
			"-o", "UserKnownHostsFile=/dev/null",
			# And don't ask about saving host keys to /dev/null ...
			"-o", "StrictHostKeyChecking=no",
			]
		if node.keyfile:
			command += ["-i", node.keyfile]


		command.append("%s@%s" % (user, address))

		cmdline = " ".join(command)
		print("Now connect to %s" % instance)
		print("  %s" % cmdline)
		os.system(cmdline)

def build_arg_parser():
	import argparse

	parser = argparse.ArgumentParser(description = 'Provision test instances.')
	parser.add_argument('--workspace',
			    help = 'the directory to use as workspace')
	parser.add_argument('--quiet', default = False, action = 'store_true',
			    help = 'Disable most output')
	parser.add_argument('--status',
			    help = 'path to the file to store status info [default $workspace/status.conf]')
	parser.add_argument('--debug', default = False, action = 'store_true',
			    help = 'Enable debug output')

	sub = parser.add_subparsers(dest = 'command')

	sp = sub.add_parser('init', help = 'Initialize a run')
	sp.set_defaults(action = ActionInit)
	sp.add_argument('--config', action = 'append', default = [],
			help='path to the file describing the nodes to be provisioned')
	sp.add_argument('--backend', default = 'vagrant',
			help = 'the provisioning backend to use [vagrant]')
	sp.add_argument('--logspace',
			help = 'the default location for test runs to write their log files to')

	sp = sub.add_parser('build', help = 'Build a silver image')
	sp.set_defaults(action = ActionBuild)
	sp.add_argument('--auto-destroy', default = False, action = 'store_true',
			help = 'if one or more of the requested nodes are running, destroy them')
	sp.add_argument('target', metavar='TARGET', nargs='?',
			help = 'name of the target image to be built')

	sp = sub.add_parser('create', help = 'Create the requested nodes')
	sp.set_defaults(action = ActionCreate)
	sp.add_argument('--auto-destroy', default = False, action = 'store_true',
			help = 'if one or more of the requested nodes are running, destroy them')

	sp = sub.add_parser('destroy', help = 'Destroy the topology')
	sp.set_defaults(action = ActionDestroy)
	sp.add_argument('--zap', default = False, action = 'store_true',
			help = 'Remove the workspace as well, empty')
	sp.add_argument('--force', default = False, action = 'store_true',
			help = 'If used with --zap, remove the workspace and everything it contains')

	sp = sub.add_parser('status', help = 'Display status on the topology')
	sp.set_defaults(action = ActionStatus)

	sp = sub.add_parser('show', help = 'Display info on the test case')
	sp.set_defaults(action = ActionShow)
	sp.add_argument('info_type', metavar='INFO-TYPE', nargs = '+',
			help='info type to display (status-file, ...)')

	sp = sub.add_parser('login', help = 'Log into the indicated node')
	sp.set_defaults(action = ActionLogin)
	sp.add_argument('node', metavar='NODE-NAME', nargs = 1,
			help='the node name of the system to connect to')

	sp = sub.add_parser('help', help = 'Print this message')
	sp.set_defaults(action = ActionHelp)

	return parser


parser = build_arg_parser()
args = parser.parse_args()

if args.debug:
	setVerbosity(2)
elif not args.quiet:
	setVerbosity(1)
else:
	setVerbosity(0)

if not args.command:
	print("Error: missing subcommand")
	parser.print_help()
	exit(2)

action = args.action(args)
action.perform()
